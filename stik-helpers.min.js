// Version: 0.3.0 | From: 24-06-2014

!function(){function withDependencies(){for(var name in modules)tmpDependencies.hasOwnProperty(name)||(tmpDependencies[name]=modules[name]);return tmpDependencies}var helpers={},modules={},tmpDependencies={};window.stik.helper=function(as,func){if(!as)throw"Stik: Helper needs a name";if(!func||"function"!=typeof func)throw"Stik: Helper needs a function";return modules[as]=window.stik.injectable({module:func,resolvable:!0}),helpers[as]=function(){var func=modules[as].resolve(withDependencies());return func.apply({},arguments)},helpers[as]},helpers.pushDoubles=function(doubles){for(var name in doubles)tmpDependencies[name]=window.stik.injectable({module:doubles[name]})},helpers.cleanDoubles=function(){tmpDependencies={}},window.stik.boundary({as:"$h",to:helpers})}(),window.stik.boundary({as:"$window",to:window}),window.stik.helper("$window",function(){return window}),window.stik.helper("isArray",function(){return function(obj){return"[object Array]"===Object.prototype.toString.call(obj)}}),window.stik.helper("debounce",function(){return function(func,wait,immediate){var timeout;return function(){var context=this,args=arguments,later=function(){timeout=null,immediate||func.apply(context,args)},callNow=immediate&&!timeout;clearTimeout(timeout),timeout=setTimeout(later,wait),callNow&&func.apply(context,args)}}}),window.stik.helper("deepExtend",function(){return function(destination,source){for(var property in source)Object.isObjectLiteral(destination[property])&&Object.isObjectLiteral(source[property])?(destination[property]=destination[property]||{},arguments.callee(destination[property],source[property])):destination[property]=source[property];return destination}}),window.stik.helper("promise",function(){return function(){return{fail:function(callback){this.reject=callback},then:function(callback,callback1){this.resolve=callback,void 0!==callback1?this.reject=callback1:!1}}}}),window.stik.helper("zip",function(){return function(firstArray,secondArray){for(var matrix=[],i=0;i<firstArray.length;i++)matrix.push([]),matrix[i].push(firstArray[i]),matrix[i].push(secondArray[i]);return matrix}});